<html>
    <head>
        <meta charset="utf-8">
        
            <script>function neighbourhoodHighlight(params) {
  // console.log("in nieghbourhoodhighlight");
  allNodes = nodes.get({ returnType: "Object" });
  // originalNodes = JSON.parse(JSON.stringify(allNodes));
  // if something is selected:
  if (params.nodes.length > 0) {
    highlightActive = true;
    var i, j;
    var selectedNode = params.nodes[0];
    var degrees = 2;

    // mark all nodes as hard to read.
    for (let nodeId in allNodes) {
      // nodeColors[nodeId] = allNodes[nodeId].color;
      allNodes[nodeId].color = "rgba(200,200,200,0.5)";
      if (allNodes[nodeId].hiddenLabel === undefined) {
        allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }
    var connectedNodes = network.getConnectedNodes(selectedNode);
    var allConnectedNodes = [];

    // get the second degree nodes
    for (i = 1; i < degrees; i++) {
      for (j = 0; j < connectedNodes.length; j++) {
        allConnectedNodes = allConnectedNodes.concat(
          network.getConnectedNodes(connectedNodes[j])
        );
      }
    }

    // all second degree nodes get a different color and their label back
    for (i = 0; i < allConnectedNodes.length; i++) {
      // allNodes[allConnectedNodes[i]].color = "pink";
      allNodes[allConnectedNodes[i]].color = "rgba(150,150,150,0.75)";
      if (allNodes[allConnectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[allConnectedNodes[i]].label =
          allNodes[allConnectedNodes[i]].hiddenLabel;
        allNodes[allConnectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // all first degree nodes get their own color and their label back
    for (i = 0; i < connectedNodes.length; i++) {
      // allNodes[connectedNodes[i]].color = undefined;
      allNodes[connectedNodes[i]].color = nodeColors[connectedNodes[i]];
      if (allNodes[connectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[connectedNodes[i]].label =
          allNodes[connectedNodes[i]].hiddenLabel;
        allNodes[connectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // the main node gets its own color and its label back.
    // allNodes[selectedNode].color = undefined;
    allNodes[selectedNode].color = nodeColors[selectedNode];
    if (allNodes[selectedNode].hiddenLabel !== undefined) {
      allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
      allNodes[selectedNode].hiddenLabel = undefined;
    }
  } else if (highlightActive === true) {
    // console.log("highlightActive was true");
    // reset all nodes
    for (let nodeId in allNodes) {
      // allNodes[nodeId].color = "purple";
      allNodes[nodeId].color = nodeColors[nodeId];
      // delete allNodes[nodeId].color;
      if (allNodes[nodeId].hiddenLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
        allNodes[nodeId].hiddenLabel = undefined;
      }
    }
    highlightActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length > 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    // console.log("Nothing was selected");
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        // allNodes[nodeId].color = {};
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function filterHighlight(params) {
  allNodes = nodes.get({ returnType: "Object" });
  // if something is selected:
  if (params.nodes.length > 0) {
    filterActive = true;
    let selectedNodes = params.nodes;

    // hiding all nodes and saving the label
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = true;
      if (allNodes[nodeId].savedLabel === undefined) {
        allNodes[nodeId].savedLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }

    for (let i=0; i < selectedNodes.length; i++) {
      allNodes[selectedNodes[i]].hidden = false;
      if (allNodes[selectedNodes[i]].savedLabel !== undefined) {
        allNodes[selectedNodes[i]].label = allNodes[selectedNodes[i]].savedLabel;
        allNodes[selectedNodes[i]].savedLabel = undefined;
      }
    }

  } else if (filterActive === true) {
    // reset all nodes
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = false;
      if (allNodes[nodeId].savedLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].savedLabel;
        allNodes[nodeId].savedLabel = undefined;
      }
    }
    filterActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length > 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function selectNode(nodes) {
  network.selectNodes(nodes);
  neighbourhoodHighlight({ nodes: nodes });
  return nodes;
}

function selectNodes(nodes) {
  network.selectNodes(nodes);
  filterHighlight({nodes: nodes});
  return nodes;
}

function highlightFilter(filter) {
  let selectedNodes = []
  let selectedProp = filter['property']
  if (filter['item'] === 'node') {
    let allNodes = nodes.get({ returnType: "Object" });
    for (let nodeId in allNodes) {
      if (allNodes[nodeId][selectedProp] && filter['value'].includes((allNodes[nodeId][selectedProp]).toString())) {
        selectedNodes.push(nodeId)
      }
    }
  }
  else if (filter['item'] === 'edge'){
    let allEdges = edges.get({returnType: 'object'});
    // check if the selected property exists for selected edge and select the nodes connected to the edge
    for (let edge in allEdges) {
      if (allEdges[edge][selectedProp] && filter['value'].includes((allEdges[edge][selectedProp]).toString())) {
        selectedNodes.push(allEdges[edge]['from'])
        selectedNodes.push(allEdges[edge]['to'])
      }
    }
  }
  selectNodes(selectedNodes)
}</script>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
            <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            
            
            
            
            
            

        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
          crossorigin="anonymous"
        />
        <script
          src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
          crossorigin="anonymous"
        ></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 100%;
                 height: 800px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             

             

             
        </style>
    </head>


    <body>
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"></div>
        </div>

        
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "#1f77b4", "id": "e1", "label": "SYSTRAN SAS", "shape": "dot", "size": 15, "title": "ID: e1\u003cbr\u003eType: pekg:Company\u003cbr\u003ename: SYSTRAN SAS\u003cbr\u003edescription: A company whose bylaws were updated on 30 November 2022, detailing provisions for share capital, preferred shares, and share payment."}, {"color": "#e7969c", "id": "e2", "label": "Bylaws Update", "shape": "dot", "size": 15, "title": "ID: e2\u003cbr\u003eType: pekg:HistoricalEvent\u003cbr\u003eeventName: Bylaws Update\u003cbr\u003eeventType: Corporate Governance Update\u003cbr\u003edateOrYear: 30 November 2022\u003cbr\u003edescription: Update to the bylaws of SYSTRAN SAS, covering aspects of share capital, preferred shares, and payment terms for shares."}, {"color": "#9467bd", "id": "e3", "label": "Cash Shares", "shape": "dot", "size": 15, "title": "ID: e3\u003cbr\u003eType: pekg:ProductOrService\u003cbr\u003ename: Cash Shares\u003cbr\u003ecategory: Equity\u003cbr\u003edescription: Shares that must be paid up at subscription for their nominal value and any premium."}, {"color": "#9467bd", "id": "e4", "label": "Fractional Shares", "shape": "dot", "size": 15, "title": "ID: e4\u003cbr\u003eType: pekg:ProductOrService\u003cbr\u003ename: Fractional Shares\u003cbr\u003ecategory: Equity\u003cbr\u003edescription: Shares (\u0027rompus\u0027) that may arise during capital increases or decreases, requiring holders to manage their number of securities to exercise rights."}, {"color": "#9467bd", "id": "e5", "label": "Preferred Shares", "shape": "dot", "size": 15, "title": "ID: e5\u003cbr\u003eType: pekg:ProductOrService\u003cbr\u003ename: Preferred Shares\u003cbr\u003ecategory: Equity\u003cbr\u003edescription: Shares that can be created with or without voting rights, and with special rights. They cannot represent more than half of the share capital if without voting rights. They can be bought-back or converted into ordinary shares or other preferred share classes upon decision of extraordinary general meeting of shareholders."}, {"color": "#9467bd", "id": "e6", "label": "Ordinary Shares", "shape": "dot", "size": 15, "title": "ID: e6\u003cbr\u003eType: pekg:ProductOrService\u003cbr\u003ename: Ordinary Shares\u003cbr\u003ecategory: Equity\u003cbr\u003edescription: Standard shares into which preferred shares can be converted."}, {"color": "#cccccc", "id": "e7", "label": "Shareholders", "shape": "dot", "size": 15, "title": "ID: e7\u003cbr\u003eType: General\u003cbr\u003ename: Shareholders\u003cbr\u003edescription: Holders of shares in SYSTRAN SAS, including those with special benefits or preferred shares, and those liable for payments."}, {"color": "#cccccc", "id": "e8", "label": "Beneficial Owner", "shape": "dot", "size": 15, "title": "ID: e8\u003cbr\u003eType: Individual/Group\u003cbr\u003ename: Beneficial Owner\u003cbr\u003edescription: (\u0027usufruitier\u0027 in French) - party with specific rights over shares, particularly regarding preferential subscription rights."}, {"color": "#cccccc", "id": "e9", "label": "Bare Owner", "shape": "dot", "size": 15, "title": "ID: e9\u003cbr\u003eType: Individual/Group\u003cbr\u003ename: Bare Owner\u003cbr\u003edescription: (\u0027nu-propri\u00e9taire\u0027 in French) - party with specific rights over shares, particularly regarding preferential subscription rights."}, {"color": "#cccccc", "id": "e10", "label": "Defaulting Shareholder", "shape": "dot", "size": 15, "title": "ID: e10\u003cbr\u003eType: Individual/Group\u003cbr\u003ename: Defaulting Shareholder\u003cbr\u003edescription: A shareholder who has not paid up their shares by the fixed deadline, subject to legal actions by the company."}, {"color": "#2ca02c", "id": "e11", "label": "President of the company", "shape": "dot", "size": 15, "title": "ID: e11\u003cbr\u003eType: pekg:Person\u003cbr\u003efullName: President of the company\u003cbr\u003ebiographySummary: Individual responsible for calling for payment of share balances and fixing payment terms for SYSTRAN SAS."}, {"color": "#98df8a", "id": "e12", "label": "President", "shape": "dot", "size": 15, "title": "ID: e12\u003cbr\u003eType: pekg:Position\u003cbr\u003etitleName: President\u003cbr\u003edepartment: Company Leadership"}]);
                  edges = new vis.DataSet([{"arrows": "to", "from": "e1", "label": "experiencedEvent", "title": "pekg:experiencedEvent", "to": "e2"}, {"arrows": "to", "from": "e1", "label": "offers", "title": "pekg:offers", "to": "e3"}, {"arrows": "to", "from": "e1", "label": "offers", "title": "pekg:offers", "to": "e4"}, {"arrows": "to", "from": "e1", "label": "offers", "title": "pekg:offers", "to": "e5"}, {"arrows": "to", "from": "e1", "label": "offers", "title": "pekg:offers", "to": "e6"}, {"arrows": "to", "from": "e1", "label": "hasShareholder", "title": "pekg:hasShareholder", "to": "e7"}, {"arrows": "to", "from": "e1", "label": "hasShareholder", "title": "pekg:hasShareholder", "to": "e8"}, {"arrows": "to", "from": "e1", "label": "hasShareholder", "title": "pekg:hasShareholder", "to": "e9"}, {"arrows": "to", "from": "e1", "label": "hasShareholder", "title": "pekg:hasShareholder", "to": "e10"}, {"arrows": "to", "from": "e1", "label": "employs", "title": "pekg:employs", "to": "e11"}, {"arrows": "to", "from": "e11", "label": "holdsPosition", "title": "pekg:holdsPosition", "to": "e12"}, {"arrows": "to", "from": "e12", "label": "positionAt", "title": "pekg:positionAt", "to": "e1"}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {"nodes": {"shape": "dot", "size": 18, "font": {"size": 14, "face": "Tahoma"}}, "edges": {"arrows": {"to": {"enabled": true, "scaleFactor": 0.7}}, "color": {"inherit": "from"}, "smooth": {"type": "continuous", "roundness": 0.2}, "font": {"size": 10, "align": "middle"}}, "physics": {"enabled": true, "barnesHut": {"gravitationalConstant": -30000, "centralGravity": 0.3, "springLength": 250, "springConstant": 0.04, "damping": 0.09}, "minVelocity": 0.75}, "interaction": {"hover": true, "tooltipDelay": 200, "multiselect": true}, "layout": {"hierarchical": false}};

                  


                  

                  network = new vis.Network(container, data, options);

                  

                  

                  


                  

                  return network;

              }
              drawGraph();
        </script>
    </body>
</html>